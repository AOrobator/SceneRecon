package com.orobator.android.scenerecon.model;import android.util.Log;public class RunningMedian {    private static final String TAG = "RunningMedian";    private int maxLength;    private int currentLength = 0;    private Node head;    private Node tail;    private Node median;    public RunningMedian(int maxLength) {        this.maxLength = maxLength;    }    public double getMedian(double num) {        Log.d(TAG, "Num: " + num);        Node node = new Node(num);        currentLength++;        // Base case        if (head == null) {            Log.d(TAG, "head == null");            head = node;            tail = node;            median = node;            return median.num;        }        boolean passedMedian = false;        // Insert num into linked list preserving sort order least to greatest        if (head.num > node.num) {            Log.d(TAG, "head.num > node.num");            node.next = head;            head.prev = node;            head = node;            if (currentLength % 2 == 1) {                median = median.prev;            }            return median.num;        } else if (tail.num < node.num) {            Log.d(TAG, "tail.num < node.num");            tail.next = node;            node.prev = tail;            tail = node;            if (currentLength % 2 == 1) {                median = median.next;            }            return median.num;        } else {            Log.d(TAG, "not on ends");            Node traverse = head;            while (traverse.num < node.num) {                traverse = traverse.next;                if (traverse.prev == median) {                    passedMedian = true;                }            }            node.prev = traverse.prev;            node.next = traverse.next;            Node traversePrev = traverse.prev;            traversePrev.next = node;            traverse.prev = node;        }        currentLength++;        // Maintain length of list        if (currentLength > maxLength) {            tail = tail.prev;            tail.next = null;            currentLength--;        }        if (passedMedian) {            if (currentLength % 2 == 0) {                return (median.num + median.next.num) / 2;            } else {                median = median.next;                return median.num;            }        } else {            if (currentLength % 2 == 0) {                return (median.num + median.prev.num) / 2;            } else {                median = median.prev;                return median.num;            }        }    }    static class Node {        Node prev;        Node next;        double num;        protected Node(double num) {            this.num = num;        }    }}