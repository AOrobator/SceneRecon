package com.orobator.android.scenerecon.view.customviews;import android.graphics.Canvas;import android.graphics.Paint;/** * An AlignmentCircle is an object drawn on the screen to indicate the angle a * user is facing on a particular axis */public abstract class AlignmentCircle {    // Total number of AlignmentCircles on this particular axis    protected int mBrethrenCount;    // The angle represented by this AlignmentCircle    protected float mCircleAngle;    // The paint used to color the AlignmentCircle    protected Paint mPaint;    // The radius of the AlignmentCircle    protected float mRadius;    protected boolean debug = true;    /**     * Method used to draw the AlignmentCircle on a canvas     */    public abstract void drawSelf(Canvas canvas, float rotationAngle);    /**     * Returns the width of the canvas in degrees     */    protected float getCanvasWidth() {        return 360 / mBrethrenCount * 2;    }    /**     * Returns the length of the canvas covered by the degrees given     */    protected float getCanvasLengthFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getWidth() / getCanvasWidth());    }    /**     * Returns the amount of degrees represented by a length of canvas     */    protected float getDegreesFromCanvasWidth(float length, Canvas canvas) {        return length * (canvas.getWidth() / 360);    }    /**     * Returns whether or not the AlignmentCircle is viewable on the canvas     * based on the direction the user is currently facing.     */    protected boolean isOnScreen(float rotationAngle, Canvas canvas) {        if (rotationAngle < 0) {            rotationAngle += 360;        }        float radiusDegrees = getDegreesFromCanvasWidth(mRadius, canvas);        double upperBound = rotationAngle + (getCanvasWidth() / 2) + radiusDegrees;        double lowerBound = rotationAngle - (getCanvasWidth() / 2) - radiusDegrees;        return mCircleAngle > lowerBound && mCircleAngle < upperBound;    }}