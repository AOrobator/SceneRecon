package com.orobator.android.scenerecon.view.customviews;import android.graphics.Canvas;import android.graphics.Paint;/** * An AlignmentCircle is an object drawn on the screen to indicate the angle a * user around the z and y earth axes */public class AlignmentCircle {    // Total number of AlignmentCircles on this particular axis    protected int mBrethrenCount;    // The yaw represented by this AlignmentCircle    protected float mYaw;    // The roll represented by this AlignmentCircle    protected float mRoll;    // The paint used to color the AlignmentCircle    protected Paint mPaint;    // The radius of the AlignmentCircle    protected float mRadius;    protected boolean debug = true;    public AlignmentCircle(int brethrenCount, float yaw, float roll, Paint paint, float radius) {        mBrethrenCount = brethrenCount;        mYaw = yaw;        mRoll = roll;        mPaint = paint;        mRadius = radius;    }    /**     * Method used to draw the AlignmentCircle on a canvas     */    public void drawSelf(Canvas canvas, float yaw, float roll) {        if (!isOnScreen(yaw, roll, canvas)) {            return;        }        if (yaw < 0) {            yaw += 360;        }        if (roll < 0) {            roll += 360;        }        float offsetFromCenterCanvasY = mRoll - roll; // in degrees        offsetFromCenterCanvasY = getCanvasHeightFromDegrees(offsetFromCenterCanvasY, canvas); // in pixels        float cy = (canvas.getHeight() / 2) + offsetFromCenterCanvasY;        float offsetFromCenterCanvasX = yaw - mYaw; // in degrees        offsetFromCenterCanvasX = getCanvasLengthFromDegrees(offsetFromCenterCanvasX, canvas); // in pixels        float cx = canvas.getWidth() / 2 + offsetFromCenterCanvasX;        canvas.drawCircle(cx, cy, mRadius, mPaint);        // Draw left line        float leftStartX = cx - canvas.getWidth() / 2 + mRadius;        float leftStartY = cy;        float leftStopX = cx - mRadius;        float leftStopY = cy;        canvas.drawLine(leftStartX, leftStartY, leftStopX, leftStopY, mPaint);        // Draw right line        float rightStartX = cx + mRadius;        float rightStartY = cy;        float rightStopX = cx + canvas.getWidth() / 2 - mRadius;        float rightStopY = cy;        canvas.drawLine(rightStartX, rightStartY, rightStopX, rightStopY, mPaint);        // Draw bottom line        float bottomStartX = cx;        float bottomStartY = cy + mRadius;        float bottomStopX = cx;        float bottomStopY = cy + (canvas.getHeight() / 2) - mRadius;        canvas.drawLine(bottomStartX, bottomStartY, bottomStopX, bottomStopY, mPaint);        // Draw top line        float topStartX = cx;        float topStartY = cy - mRadius;        float topStopX = cx;        float topStopY = cy - (canvas.getHeight() / 2) + mRadius;        canvas.drawLine(topStartX, topStartY, topStopX, topStopY, mPaint);        if (debug) {            mPaint.setTextSize(45);            canvas.drawText(String.valueOf(mRoll), cx - 3 * mRadius / 4, cy + mRadius / 5, mPaint);        }    }    /**     * Returns the width of the canvas in degrees     */    protected float getCanvasWidthInDegrees() {        return 360 / mBrethrenCount * 2;    }    /**     * Returns the height of the canvas in degrees     */    protected float getCanvasHeightInDegrees() {        return 360 / mBrethrenCount * 2;    }    /**     * Returns the length of the canvas covered by the degrees given     */    protected float getCanvasLengthFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getWidth() / getCanvasWidthInDegrees());    }    /**     * Returns the height of the canvas covered by the degrees given     */    protected float getCanvasHeightFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getHeight() / getCanvasHeightInDegrees());    }    /**     * Returns the amount of degrees represented by a length of canvas     */    protected float getDegreesFromCanvasWidth(float length, Canvas canvas) {        return length * (canvas.getWidth() / 360);    }    /**     * Returns the amount of degrees represented by a portion of the height of     * the canvas     */    protected float getDegreesFromCanvasHeight(float length, Canvas canvas) {        return length * (canvas.getHeight() / 360);    }    /**     * Returns whether or not the AlignmentCircle is viewable on the canvas     * based on the direction the user is currently facing.     */    protected boolean isOnScreen(float yaw, float roll, Canvas canvas) {        if (yaw < 0) {            yaw += 360;        }        float yawDegrees = getDegreesFromCanvasWidth(mRadius, canvas);        double upperBoundYaw = yaw + (getCanvasWidthInDegrees() / 2) + yawDegrees;        double lowerBoundYaw = yaw - (getCanvasWidthInDegrees() / 2) - yawDegrees;        double rollDegrees = getDegreesFromCanvasHeight(mRadius, canvas);        double upperBoundRoll = roll + (getCanvasHeightInDegrees() / 2) + rollDegrees;        double lowerBoundRoll = roll - (getCanvasHeightInDegrees() / 2) - rollDegrees;        return (mYaw > lowerBoundYaw && mYaw < upperBoundYaw)                && (mRoll > lowerBoundRoll && mRoll < upperBoundRoll);    }}