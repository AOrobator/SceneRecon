package com.orobator.android.scenerecon.view.customviews;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.RectF;/** * An AlignmentCircle is an object drawn on the screen to indicate the angle a * user is around the z and y earth axes. See research log for axes definition. */public class AlignmentCircle {    // Total number of AlignmentCircles on this particular axis    private int mBrethrenCount;    // The yaw represented by this AlignmentCircle    private float mYaw;    // The roll represented by this AlignmentCircle    private float mRoll;    // The paint used to color the AlignmentCircle    private Paint mPaint;    // The radius of the AlignmentCircle    private float mRadius;    // Indicates whether a picture has been taken with this AlignmentCircle    private boolean pictureTaken = false;    // Icon placed on circle if a picture has been taken at the AlignmentCircle    private Bitmap cameraIcon;    private boolean debug = false;    public AlignmentCircle(Bitmap cameraIcon, int brethrenCount, float yaw, float roll, Paint paint, float radius) {        mBrethrenCount = brethrenCount;        mYaw = yaw;        mRoll = roll;        mPaint = paint;        mRadius = radius;        this.cameraIcon = cameraIcon;    }    /**     * Method used to draw the AlignmentCircle on a canvas     */    public void drawSelf(Canvas canvas, float yaw, float roll) {        // Don't draw the circle on the canvas if it won't be seen        if (!isOnScreen(yaw, roll, canvas)) {            return;        }        if (yaw < 0) {            yaw += 360;        }        if (roll < 0) {            roll += 360;        }        float offsetFromCenterCanvasY = mRoll - roll; // in degrees        offsetFromCenterCanvasY = getCanvasHeightFromDegrees(offsetFromCenterCanvasY, canvas); // in pixels        float cy = (canvas.getHeight() / 2) + offsetFromCenterCanvasY;        float offsetFromCenterCanvasX = yaw - mYaw; // in degrees        offsetFromCenterCanvasX = getCanvasLengthFromDegrees(offsetFromCenterCanvasX, canvas); // in pixels        float cx = canvas.getWidth() / 2 + offsetFromCenterCanvasX;        canvas.drawCircle(cx, cy, mRadius, mPaint);        // Draw left line        float leftStartX = cx - canvas.getWidth() / 2 + mRadius;        float leftStartY = cy;        float leftStopX = cx - mRadius;        float leftStopY = cy;        canvas.drawLine(leftStartX, leftStartY, leftStopX, leftStopY, mPaint);        // Draw right line        float rightStartX = cx + mRadius;        float rightStartY = cy;        float rightStopX = cx + canvas.getWidth() / 2 - mRadius;        float rightStopY = cy;        canvas.drawLine(rightStartX, rightStartY, rightStopX, rightStopY, mPaint);        // Draw bottom line        float bottomStartX = cx;        float bottomStartY = cy + mRadius;        float bottomStopX = cx;        float bottomStopY = cy + (canvas.getHeight() / 2) - mRadius;        canvas.drawLine(bottomStartX, bottomStartY, bottomStopX, bottomStopY, mPaint);        // Draw top line        float topStartX = cx;        float topStartY = cy - mRadius;        float topStopX = cx;        float topStopY = cy - (canvas.getHeight() / 2) + mRadius;        canvas.drawLine(topStartX, topStartY, topStopX, topStopY, mPaint);        if (pictureTaken) {            RectF rectf = new RectF();            rectf.bottom = (float) (cy + mRadius * Math.sin(Math.toRadians(45)));            rectf.top = (float) (cy - mRadius * Math.sin(Math.toRadians(45)));            rectf.left = (float) (cx - mRadius * Math.cos(Math.toRadians(45)));            rectf.right = (float) (cx + mRadius * Math.cos(Math.toRadians(45)));            canvas.drawBitmap(cameraIcon, null, rectf, mPaint);        }        if (debug) {            mPaint.setTextSize(45);            canvas.drawText(String.valueOf(mRoll), cx - 3 * mRadius / 4, cy + mRadius / 5, mPaint);        }    }    // Used to indicate that a picture has been taken on this AlignmentCircle    public void pictureTaken() {        pictureTaken = true;    }    public boolean isPictureTaken() {        return pictureTaken;    }    /**     * Returns the width of the canvas in degrees     */    private float getCanvasWidthInDegrees() {        return 360 / mBrethrenCount * 2;    }    /**     * Returns the height of the canvas in degrees     */    private float getCanvasHeightInDegrees() {        return 360 / mBrethrenCount * 2;    }    /**     * Returns the length of the canvas covered by the degrees given     */    private float getCanvasLengthFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getWidth() / getCanvasWidthInDegrees());    }    /**     * Returns the height of the canvas covered by the degrees given     */    private float getCanvasHeightFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getHeight() / getCanvasHeightInDegrees());    }    /**     * Returns the amount of degrees represented by a length of canvas     */    private float getDegreesFromCanvasWidth(float length, Canvas canvas) {        return length * (canvas.getWidth() / 360);    }    /**     * Returns the amount of degrees represented by a portion of the height of     * the canvas     */    private float getDegreesFromCanvasHeight(float length, Canvas canvas) {        return length * (canvas.getHeight() / 360);    }    public float getRoll() {        return mRoll;    }    public float getYaw() {        return mYaw;    }    /**     * Returns whether or not the AlignmentCircle is viewable on the canvas     * based on the direction the user is currently facing.     */    private boolean isOnScreen(float yaw, float roll, Canvas canvas) {        if (yaw < 0) {            yaw += 360;        }        float yawDegrees = getDegreesFromCanvasWidth(mRadius, canvas);        double upperBoundYaw = yaw + (getCanvasWidthInDegrees() / 2) + yawDegrees;        double lowerBoundYaw = yaw - (getCanvasWidthInDegrees() / 2) - yawDegrees;        double rollDegrees = getDegreesFromCanvasHeight(mRadius, canvas);        double upperBoundRoll = roll + (getCanvasHeightInDegrees() / 2) + rollDegrees;        double lowerBoundRoll = roll - (getCanvasHeightInDegrees() / 2) - rollDegrees;        return (mYaw > lowerBoundYaw && mYaw < upperBoundYaw)                && (mRoll > lowerBoundRoll && mRoll < upperBoundRoll);    }}