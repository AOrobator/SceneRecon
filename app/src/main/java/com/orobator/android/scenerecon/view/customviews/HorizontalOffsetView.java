package com.orobator.android.scenerecon.view.customviews;import android.content.Context;import android.content.res.Resources;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Paint;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.util.AttributeSet;import android.util.Log;import android.util.TypedValue;import android.view.View;import com.orobator.android.scenerecon.R;/** * HorizontalOffSetView is a custom view used to indicate if the device is * horizontal with respect to the ground */public class HorizontalOffsetView extends View implements SensorEventListener {    private static final String TAG = "HorizontalOffsetView";    private int backgroundColor;    private int baseLineColor;    private int unalignedIndicatorColor;    private int alignedIndicatorColor;    private double horizontalOffset = 0;    private double zDeviceGravity = 0;    private float mRoll;    private float mPitch = 0f;    private float mStrokeWidth;    private float mCircleRadius;    private float[] mGravityOrientation = new float[3];    private float[] mGeomagneticOrientation = new float[3];    private boolean isAligned;    private Paint mBackgroundPaint;    private Paint mBaseLinePaint;    private Paint mUnalignedPaint;    private Paint mAlignedPaint;    private Paint mIndicatorPaint;    private EventListener mEventListener;    private SensorManager mSensorManager;    private Sensor mGravitySensor;    private Sensor mMagneticFieldSensor;    private Sensor mAccelerometer;    private Sensor mRotationVector;    private AlignmentCircle[][] mAlignmentCircles;    public HorizontalOffsetView(Context context, AttributeSet attrs) {        super(context, attrs);        TypedArray typedArray = context.getTheme().obtainStyledAttributes(                attrs, R.styleable.HorizontalOffsetView, 0, 0);        try {            backgroundColor = typedArray.getColor(R.styleable.HorizontalOffsetView_background_color, 0);            baseLineColor = typedArray.getColor(R.styleable.HorizontalOffsetView_base_line_color, 0);            unalignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_unaligned, 0);            alignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_aligned, 0);        } finally {            typedArray.recycle();        }        initConstants();        initSensors();        initPaints();        initYawCircles();    }    /**     * Draws the baseline that the indicator line is to align with.     */    private void drawBase(Canvas canvas) {        for (AlignmentCircle[] yaw : mAlignmentCircles) {            for (AlignmentCircle alignmentCircle : yaw) {                alignmentCircle.drawSelf(canvas, mPitch, mRoll);            }        }    }    private void drawIndicatorCircle(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Draw the circle in the base line        mIndicatorPaint = isAligned ? mAlignedPaint : mUnalignedPaint;        canvas.drawCircle(centerX, centerY, mCircleRadius, mIndicatorPaint);    }    private void drawIndicatorLine(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Lines are drawn from left to right        // Line coordinates touching edges of screen        float startX_left = 0f;        float startY_left = (float) (centerY - centerX * Math.tan(Math.toRadians(horizontalOffset)));  // Depends on horizontal offset        float stopX_right = (float) canvas.getWidth();        float stopY_right = (float) (centerY + centerX * Math.tan(Math.toRadians(horizontalOffset))); // Depends on horizontal offset        // Line coordinates touching indicator circle        float stopX_left = centerX - (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float stopY_left = centerY - (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        float startX_right = centerX + (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float startY_right = centerY + (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        canvas.drawLine(startX_left, startY_left, stopX_left, stopY_left, mIndicatorPaint);        canvas.drawLine(startX_right, startY_right, stopX_right, stopY_right, mIndicatorPaint);    }    private void drawIndicator(Canvas canvas) {        drawIndicatorCircle(canvas);        drawIndicatorLine(canvas);    }    public int getAlignedIndicatorColor() {        return alignedIndicatorColor;    }    public int getBackgroundColor() {        return backgroundColor;    }    public int getBaseLineColor() {        return baseLineColor;    }    public String getCurrentRotations() {        return "_Roll_" + Float.toString(mRoll) + "_Pitch_" + Float.toString(mPitch);    }    public int getUnalignedIndicatorColor() {        return unalignedIndicatorColor;    }    private void initConstants() {        int thickness = 2; // Thickness of line in dp        Resources r = getResources();        mStrokeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, thickness, r.getDisplayMetrics());        int radiusDP = 26; // radius in DP        mCircleRadius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, radiusDP, r.getDisplayMetrics()); // radius in pixels    }    /**     * Set up Paint objects for drawing. Instantiating Paint objects is     * expensive so don't do it in onDraw()     */    private void initPaints() {        mBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBaseLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mUnalignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mAlignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBackgroundPaint.setColor(backgroundColor); // TODO: Get rid of background paint        mBaseLinePaint.setColor(baseLineColor);        mUnalignedPaint.setColor(unalignedIndicatorColor);        mAlignedPaint.setColor(alignedIndicatorColor);        mBaseLinePaint.setStyle(Paint.Style.STROKE);        mUnalignedPaint.setStyle(Paint.Style.STROKE);        mAlignedPaint.setStyle(Paint.Style.STROKE);        mBaseLinePaint.setStrokeWidth(mStrokeWidth);        mUnalignedPaint.setStrokeWidth(mStrokeWidth);        mAlignedPaint.setStrokeWidth(mStrokeWidth);    }    /**     * Initiates the sensor and registers it for the first time     */    private void initSensors() {        mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);        mGravitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);        mMagneticFieldSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);        mRotationVector = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);        registerSensorListener();    }    /**     * Instantiate YawCircles in the beginning to avoid repeated object     * creation in onDraw()     */    public void initYawCircles() {        int brethrenCount = 36; // TODO: change to be configurable, for now each circle will cover 10 degrees        mAlignmentCircles = new AlignmentCircle[brethrenCount + 2][brethrenCount + 2];        for (int i = 0; i < brethrenCount + 2; i++) { // add 2 to get overlap of circles > 359 degrees            for (int j = 0; j < brethrenCount + 2; j++) {                float yaw = (360 / brethrenCount) * i;                float roll = (360 / brethrenCount) * j;                AlignmentCircle alignmentCircle = new AlignmentCircle(brethrenCount, yaw, roll, mBaseLinePaint, mCircleRadius);                mAlignmentCircles[i][j] = alignmentCircle;            }        }    }    @Override    public boolean isInEditMode() {        return true;    }    @Override    public void onAccuracyChanged(Sensor sensor, int accuracy) {    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        drawBase(canvas);        drawIndicator(canvas);    }    @Override    public void onSensorChanged(SensorEvent event) {        final float alpha = 0.97f;        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {            // mGravityOrientation = event.values;            mGravityOrientation[0] = alpha * mGravityOrientation[0] + (1 - alpha) * event.values[0];            mGravityOrientation[1] = alpha * mGravityOrientation[1] + (1 - alpha) * event.values[1];            mGravityOrientation[2] = alpha * mGravityOrientation[2] + (1 - alpha) * event.values[2];        }        if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {            // mGeomagneticOrientation = event.values;            mGeomagneticOrientation[0] = alpha * mGeomagneticOrientation[0] + (1 - alpha) * event.values[0];            mGeomagneticOrientation[1] = alpha * mGeomagneticOrientation[1] + (1 - alpha) * event.values[1];            mGeomagneticOrientation[2] = alpha * mGeomagneticOrientation[2] + (1 - alpha) * event.values[2];        }        if (event.sensor.getType() == Sensor.TYPE_GRAVITY) {            // units in m/s^2            double yAxisGravity = event.values[1];            zDeviceGravity = event.values[2];            // Angle in degrees of device offset from horizontal            horizontalOffset = Math.toDegrees(Math.acos(yAxisGravity / SensorManager.GRAVITY_EARTH)) - 90;            if (horizontalOffset < 0) {                horizontalOffset += 360;            }//            Log.d(TAG, "horizontal offset: " + horizontalOffset);            float epsilon = 2f;            float horizontal = 0f; // Angle in degrees representing the horizontal            if (horizontalOffset > (360 - epsilon) || horizontalOffset < (horizontal + epsilon)) {                isAligned = true;                if (mEventListener != null) {                    mEventListener.onAligned();                }            } else {                isAligned = false;                if (mEventListener != null) {                    mEventListener.onUnAligned(horizontalOffset);                }            }        }        if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {            float rotationMatrix[] = new float[9];            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values);            mRoll = (float) Math.toDegrees(Math.acos(rotationMatrix[6])); //only from 0 -> 180            if (zDeviceGravity > 0) {                mRoll = 360 - mRoll;            }            mRoll = 180 - mRoll;            if (mRoll < 0) {                mRoll += 360;            }            Log.d(TAG, "mRoll: " + mRoll + "   zDeviceGravity: " + zDeviceGravity);        }        float R[] = new float[9];        float I[] = new float[9];        boolean success = SensorManager.getRotationMatrix(R, I, mGravityOrientation, mGeomagneticOrientation);        if (success) {            float orientation[] = new float[3];            SensorManager.getOrientation(R, orientation);            mPitch = (float) Math.toDegrees(orientation[0]);            // Make angle increase in direction opposite to motion for better effect            mPitch = 360 - ((mPitch + 360) % 360);            // Redraw the view            invalidate();        }    }    /**     * An EventListener can be registered with the HorizontalOffsetView so it     * can be notified when the device becomes horizontal, and when it is no     * longer horizontal     */    public interface EventListener {        /**         * Called when the device first becomes horizontal         */        public void onAligned();        /**         * Called when the device first becomes non-horizontal with an argument         * of the device offset in degrees         */        public void onUnAligned(double offset);    }    /**     * Gives this view a new EventListener     */    public void registerEventListener(EventListener listener) {        mEventListener = listener;    }    public void registerSensorListener() {        mSensorManager.registerListener(this, mGravitySensor, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mMagneticFieldSensor, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mRotationVector, SensorManager.SENSOR_DELAY_GAME);    }    public void setAlignedIndicatorColor(int alignedIndicatorColor) {        this.alignedIndicatorColor = alignedIndicatorColor;        invalidate();        requestLayout();    }    public void setBackgroundColor(int backgroundColor) {        this.backgroundColor = backgroundColor;        invalidate();        requestLayout();    }    public void setBaseLineColor(int baseLineColor) {        this.baseLineColor = baseLineColor;        invalidate();        requestLayout();    }    public void setUnalignedIndicatorColor(int unalignedIndicatorColor) {        this.unalignedIndicatorColor = unalignedIndicatorColor;        invalidate();        requestLayout();    }    /**     * Removes the EventListener     */    public void unregisterEventListener() {        mEventListener = null;    }    /**     * unregisterSensorListener() needs to be called when the widget is no longer in use to prevent     * leaking the sensor and draining battery life. A good idea would be to     * call it in onPause() of whatever Activity or Fragment is hosting this view     */    public void unregisterSensorListener() {        mSensorManager.unregisterListener(this);    }}