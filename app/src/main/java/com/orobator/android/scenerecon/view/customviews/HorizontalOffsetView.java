package com.orobator.android.scenerecon.view.customviews;import android.content.Context;import android.content.res.Resources;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Paint;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.util.AttributeSet;import android.util.Log;import android.util.TypedValue;import android.view.View;import com.orobator.android.scenerecon.R;/** * HorizontalOffSetView is a custom view used to indicate if the device is * horizontal with respect to the ground */public class HorizontalOffsetView extends View implements SensorEventListener {    private static final String TAG = "HorizontalOffsetView";    private int backgroundColor;    private int baseLineColor;    private int unalignedIndicatorColor;    private int alignedIndicatorColor;    private double xAxisGravityOffset = 0;    private boolean isAligned;    private Paint mBackgroundPaint;    private Paint mBaseLinePaint;    private Paint mUnalignedPaint;    private Paint mAlignedPaint;    private EventListener mEventListener;    private SensorManager mSensorManager;    private Sensor mGravitySensor;    public HorizontalOffsetView(Context context, AttributeSet attrs) {        super(context, attrs);        TypedArray typedArray = context.getTheme().obtainStyledAttributes(                attrs, R.styleable.HorizontalOffsetView, 0, 0);        try {            backgroundColor = typedArray.getColor(R.styleable.HorizontalOffsetView_background_color, 0);            baseLineColor = typedArray.getColor(R.styleable.HorizontalOffsetView_base_line_color, 0);            unalignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_unaligned, 0);            alignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_aligned, 0);        } finally {            typedArray.recycle();        }        initPaints();        initSensor();    }    public void registerSensorListener() {        mSensorManager.registerListener(this, mGravitySensor, SensorManager.SENSOR_DELAY_GAME);    }    /**     * unregisterSensorListener() needs to be called when the widget is no longer in use to prevent     * leaking the sensor and draining battery life. A good idea would be to     * call it in onPause() of whatever Activity or Fragment is hosting this view     */    public void unregisterSensorListener() {        mSensorManager.unregisterListener(this);    }    /**     * Initiates the sensor and registers it for the first time     */    private void initSensor() {        mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);        mGravitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);        registerSensorListener();    }    /**     * Set up Paint objects for drawing. Instantiating Paint objects is     * expensive so don't do it in onDraw()     */    private void initPaints() {        mBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBaseLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mUnalignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mAlignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBackgroundPaint.setColor(backgroundColor);        mBaseLinePaint.setColor(baseLineColor);        mUnalignedPaint.setColor(unalignedIndicatorColor);        mAlignedPaint.setColor(alignedIndicatorColor);    }    /**     * Gives this view a new EventListener     */    public void registerEventListener(EventListener listener) {        mEventListener = listener;    }    /**     * Removes the EventListener     */    public void unregisterEventListener() {        mEventListener = null;    }    @Override    public void onSensorChanged(SensorEvent event) {        if (event.sensor.getType() == Sensor.TYPE_GRAVITY) {            // units in m/s^2            double xAxisGravity = event.values[0];            double yAxisGravity = event.values[1];            double zAxisGravity = event.values[2];            //Angle in degrees of device offset from horizontal            xAxisGravityOffset = Math.toDegrees(Math.acos(xAxisGravity / SensorManager.GRAVITY_EARTH));            Log.d(TAG, "x axis gravity offset: " + xAxisGravityOffset);            float epsilon = 2;            if (xAxisGravity < epsilon) {                if (mEventListener != null) {                    mEventListener.onAligned();                    isAligned = true;                }            }            if (xAxisGravity > epsilon) {                if (isAligned) {                    isAligned = false;                    if (mEventListener != null) {                        mEventListener.onUnAligned(xAxisGravityOffset);                    }                }            }            // Redraw the view            invalidate();        }    }    @Override    public void onAccuracyChanged(Sensor sensor, int accuracy) {    }    /**     * An EventListener can be registered with the HorizontalOffsetView so it     * can be notified when the device becomes horizontal, and when it is no     * longer horizontal     */    public interface EventListener {        /**         * Called when the device first becomes horizontal         */        public void onAligned();        /**         * Called when the device first becomes non-horizontal with an argument         * of the device offset in degrees         */        public void onUnAligned(double offset);    }    private boolean isAligned() {        double epsilon = 2.0;        if (xAxisGravityOffset < epsilon) {            return true;        }        return false;    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        int thickness = 2; // Thickness of line in dp        Resources r = getResources();        float rectWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, thickness, r.getDisplayMetrics());        int radiusDP = 26; // radius in DP        float radius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, radiusDP, r.getDisplayMetrics());      // radius in pixels        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Draw the base lines        float left_leftLine = 0f;        float top = ((float) canvas.getHeight()) / 2 - (rectWidth / 2);        float right_leftLine = centerX - radius;        float bottom = top + rectWidth;        float left_rightLine = centerX + radius;        float right_rightLine = (float) canvas.getWidth();        mBaseLinePaint.setStyle(Paint.Style.FILL);        canvas.drawRect(left_leftLine, top, right_leftLine, bottom, mBaseLinePaint);        canvas.drawRect(left_rightLine, top, right_rightLine, bottom, mBaseLinePaint);        // Draw the circle in the base line        Paint indicatorPaint = isAligned() ? mAlignedPaint : mUnalignedPaint;        indicatorPaint.setStyle(Paint.Style.STROKE);        indicatorPaint.setStrokeWidth(rectWidth);        canvas.drawCircle(centerX, centerY, radius, indicatorPaint);        // Draw indicator line        float startX_left = 0f;        float stopX_right = (float) canvas.getWidth();        float startY_left = (float) (centerY + centerX * Math.tan(Math.toRadians(xAxisGravityOffset))); // Depends on horizontal offset        float stopY_right = (float) (centerY - centerX * Math.tan(Math.toRadians(xAxisGravityOffset)));  // Depends on horizontal offset        if (xAxisGravityOffset > 90 && xAxisGravityOffset < 270) { // tan is only in 1st & 3rd quadrants            float stopX_left = centerX + (float) (radius * Math.cos(Math.toRadians(xAxisGravityOffset)));            float stopY_left = centerY - (float) (radius * Math.sin(Math.toRadians(xAxisGravityOffset)));            float startX_right = centerX - (float) (radius * Math.cos(Math.toRadians(xAxisGravityOffset)));            float startY_right = centerY + (float) (radius * Math.sin(Math.toRadians(xAxisGravityOffset)));            canvas.drawLine(startX_left, startY_left, stopX_left, stopY_left, indicatorPaint);            canvas.drawLine(startX_right, startY_right, stopX_right, stopY_right, indicatorPaint);        } else {            float stopX_left = centerX - (float) (radius * Math.cos(Math.toRadians(xAxisGravityOffset)));            float stopY_left = centerY + (float) (radius * Math.sin(Math.toRadians(xAxisGravityOffset)));            float startX_right = centerX + (float) (radius * Math.cos(Math.toRadians(xAxisGravityOffset)));            float startY_right = centerY - (float) (radius * Math.sin(Math.toRadians(xAxisGravityOffset)));            canvas.drawLine(startX_left, startY_left, stopX_left, stopY_left, indicatorPaint);            canvas.drawLine(startX_right, startY_right, stopX_right, stopY_right, indicatorPaint);        }    }    public int getBackgroundColor() {        return backgroundColor;    }    public void setBackgroundColor(int backgroundColor) {        this.backgroundColor = backgroundColor;        invalidate();        requestLayout();    }    public int getBaseLineColor() {        return baseLineColor;    }    public void setBaseLineColor(int baseLineColor) {        this.baseLineColor = baseLineColor;        invalidate();        requestLayout();    }    public int getUnalignedIndicatorColor() {        return unalignedIndicatorColor;    }    public void setUnalignedIndicatorColor(int unalignedIndicatorColor) {        this.unalignedIndicatorColor = unalignedIndicatorColor;        invalidate();        requestLayout();    }    public int getAlignedIndicatorColor() {        return alignedIndicatorColor;    }    public void setAlignedIndicatorColor(int alignedIndicatorColor) {        this.alignedIndicatorColor = alignedIndicatorColor;        invalidate();        requestLayout();    }}