package com.orobator.android.scenerecon.view.customviews;import android.content.Context;import android.content.res.Resources;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Paint;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.util.AttributeSet;import android.util.DisplayMetrics;import android.util.Log;import android.util.TypedValue;import android.view.View;import com.orobator.android.scenerecon.R;import java.text.DecimalFormat;/** * HorizontalOffSetView is a custom view used to indicate if the device is * horizontal with respect to the ground. It draws all of the AlignmentCircles * and the cross-hairs and draws itself based on the sensor data it receives. */public class HorizontalOffsetView extends View implements SensorEventListener {    private static final String TAG = "HorizontalOffsetView";    private int backgroundColor;    private int baseLineColor;    private int unalignedIndicatorColor;    private int alignedIndicatorColor;    private int mAlignmentCircleCount;    private int uniquePicturesTaken = 0;    private double horizontalOffset = 0;    private double zDeviceGravity = 0;    private float mHorizonOffset;    private float angleOffNorth = 0f;    private float mStrokeWidth;    private float mCircleRadius;    private float[] mGravityOrientation = new float[3];    private float[] mGeomagneticOrientation = new float[3];    private long sysTime = 0;    private boolean isAligned;    private Paint mBackgroundPaint;    private Paint mBaseLinePaint;    private Paint mUnalignedPaint;    private Paint mAlignedPaint;    private Paint mIndicatorPaint;    private Paint pictureCountPaint;    private Paint mStatsBackgroundPaint;    private Paint mStatsTextPaint;    private EventListener mEventListener;    private SensorManager mSensorManager;    private Sensor mGravitySensor;    private Sensor mMagneticFieldSensor;    private Sensor mAccelerometer;    private Sensor mRotationVector;    private AlignmentCircle[][] mAlignmentCircles;    private Context mContext;    public HorizontalOffsetView(Context context, AttributeSet attrs) {        super(context, attrs);        mContext = context;        TypedArray typedArray = context.getTheme().obtainStyledAttributes(                attrs, R.styleable.HorizontalOffsetView, 0, 0);        try {            backgroundColor = typedArray.getColor(R.styleable.HorizontalOffsetView_background_color, 0);            baseLineColor = typedArray.getColor(R.styleable.HorizontalOffsetView_base_line_color, 0);            unalignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_unaligned, 0);            alignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_aligned, 0);        } finally {            typedArray.recycle();        }        initConstants();        initSensors();        initPaints();        initAlignmentCircles();    }    public int dipToPixels(int dip) {        Resources r = getResources();        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, (float) dip, r.getDisplayMetrics());    }    public int spToPixels(int sp) {        DisplayMetrics metrics = getResources().getDisplayMetrics();        return (int) (metrics.scaledDensity * dipToPixels(sp));    }    /**     * Draws the baselines that the indicator line (cross-hairs) is to align     * with.     */    private void drawBase(Canvas canvas) {        for (AlignmentCircle[] yaw : mAlignmentCircles) {            for (AlignmentCircle alignmentCircle : yaw) {                alignmentCircle.drawSelf(canvas, angleOffNorth, mHorizonOffset);            }        }    }    /**     * Draws the center circle for the cross-hairs.     */    private void drawIndicatorCircle(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Draw the circle in the base line        mIndicatorPaint = isAligned ? mAlignedPaint : mUnalignedPaint;        canvas.drawCircle(centerX, centerY, mCircleRadius, mIndicatorPaint);    }    /**     * Draws the horizontal and vertical cross-hair lines.     */    private void drawIndicatorLine(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Lines are drawn from left to right and top to bottom        float startX_left = 0f;        float startY_left = (float) (centerY - centerX * Math.tan(Math.toRadians(horizontalOffset)));        float stopX_left = centerX - (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float stopY_left = centerY - (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        float startX_right = centerX + (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float startY_right = centerY + (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        float stopX_right = (float) canvas.getWidth();        float stopY_right = (float) (centerY + centerX * Math.tan(Math.toRadians(horizontalOffset)));        float startX_top = (float) (centerX - (canvas.getHeight() / 2) * Math.tan(Math.toRadians(360 - horizontalOffset)));        float startY_top = 0f;        float stopX_top = (float) (centerX - mCircleRadius * Math.sin(Math.toRadians(360 - horizontalOffset)));        float stopY_top = (float) (centerY - mCircleRadius * Math.cos(Math.toRadians(360 - horizontalOffset)));        float startX_bottom = (float) (centerX + mCircleRadius * Math.sin(Math.toRadians(360 - horizontalOffset)));        float startY_bottom = (float) (centerY + mCircleRadius * Math.cos(Math.toRadians(360 - horizontalOffset)));        float stopX_bottom = (float) (centerX + (canvas.getHeight() / 2) * Math.tan(Math.toRadians(360 - horizontalOffset)));        float stopY_bottom = canvas.getHeight();        canvas.drawLine(startX_left, startY_left, stopX_left, stopY_left, mIndicatorPaint);        canvas.drawLine(startX_right, startY_right, stopX_right, stopY_right, mIndicatorPaint);        canvas.drawLine(startX_top, startY_top, stopX_top, stopY_top, mIndicatorPaint);        canvas.drawLine(startX_bottom, startY_bottom, stopX_bottom, stopY_bottom, mIndicatorPaint);    }    /**     * Draws the cross-hairs.     */    private void drawIndicator(Canvas canvas) {        drawIndicatorCircle(canvas);        drawIndicatorLine(canvas);    }    // Draws roll, pitch, yaw, and x-y-z displacement    private void drawStats(Canvas canvas) {        int statsWidthDP = 150;        int statsWithPX = dipToPixels(statsWidthDP);        canvas.drawRect(0, 0, statsWithPX, canvas.getHeight(), mStatsBackgroundPaint);        int statXDP = 20;        int statXPX = dipToPixels(statXDP);        int rollYDP = 40;        int rollYPX = dipToPixels(rollYDP);        DecimalFormat decimalFormat = new DecimalFormat("###.###");        canvas.drawText("Roll: " + Double.valueOf(decimalFormat.format(mHorizonOffset)), statXPX, rollYPX, mStatsTextPaint);        int pitchYDP = 25;        int pitchYPX = rollYPX + spToPixels(pitchYDP);        canvas.drawText("Pitch: " + Double.valueOf(decimalFormat.format(horizontalOffset)), statXPX, pitchYPX, mStatsTextPaint);        int yawYDP = 25;        int yawYPX = pitchYPX + spToPixels(yawYDP);        canvas.drawText("Yaw: " + Double.valueOf(decimalFormat.format(angleOffNorth)), statXPX, yawYPX, mStatsTextPaint);        int picsHeaderYDP = 25;        int picsHeaderYPX = yawYPX + spToPixels(picsHeaderYDP);        canvas.drawText("Circles covered: ", statXPX, picsHeaderYPX, mStatsTextPaint);        int picsStatYDP = 5;        int picsStatYPX = picsHeaderYPX + spToPixels(picsStatYDP);        String pictureCount = Integer.toString(uniquePicturesTaken) + "/" + Integer.toString(mAlignmentCircleCount * mAlignmentCircleCount);        canvas.drawText(pictureCount, statXPX, picsStatYPX, mStatsTextPaint);    }    public int getAlignedIndicatorColor() {        return alignedIndicatorColor;    }    public int getBackgroundColor() {        return backgroundColor;    }    public int getBaseLineColor() {        return baseLineColor;    }    /**     * Call this method after taking a picture. It returns a string detailing     * the device rotation that is used for naming the image.     */    public String getCurrentRotations() {        // Look for the circle that got its picture taken and tell it that its        // picture was taken        for (AlignmentCircle[] yaw : mAlignmentCircles) {            for (AlignmentCircle circle : yaw) {                // Threshold used for determining if a particular circle had its                // picture taken                int delta = 2;                if (Math.abs(circle.getRoll() - mHorizonOffset) < delta || Math.abs(circle.getRoll() - mHorizonOffset + 360) < delta) {                    if (Math.abs(circle.getYaw() - angleOffNorth) < delta || Math.abs(circle.getYaw() - angleOffNorth + 360) < delta) {                        if (!circle.isPictureTaken()) {                            uniquePicturesTaken++;                        }                        circle.pictureTaken();                    }                }            }        }        return "_Roll_" + Float.toString(mHorizonOffset) + "_Pitch_" + Float.toString(angleOffNorth);    }    public int getUnalignedIndicatorColor() {        return unalignedIndicatorColor;    }    /**     * Instantiate AlignmentCircles in the beginning to avoid repeated object     * creation in onDraw()     */    public void initAlignmentCircles() {        mAlignmentCircleCount = 36; // TODO: change to be configurable, for now each circle will cover 10 degrees        mAlignmentCircles = new AlignmentCircle[mAlignmentCircleCount + 2][mAlignmentCircleCount + 2]; // Have some overlapping circles for visual continuity        Bitmap cameraIcon = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.ic_action_camera);        for (int i = 0; i < mAlignmentCircleCount + 2; i++) { // add 2 to get overlap of circles > 359 degrees            for (int j = 0; j < mAlignmentCircleCount + 2; j++) {                float yaw = (360 / mAlignmentCircleCount) * i;                float roll = (360 / mAlignmentCircleCount) * j;                AlignmentCircle alignmentCircle = new AlignmentCircle(cameraIcon, mAlignmentCircleCount, yaw, roll, mBaseLinePaint, mCircleRadius);                mAlignmentCircles[i][j] = alignmentCircle;            }        }    }    private void initConstants() {        int thickness = 2; // Thickness of line in dp        mStrokeWidth = dipToPixels(thickness); // Thickness of line in pixels        int radiusDP = 26; // radius in DP        mCircleRadius = dipToPixels(radiusDP); // radius in pixels    }    /**     * Set up Paint objects for drawing. Instantiating Paint objects is     * expensive so don't do it in onDraw()     */    private void initPaints() {        mBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBaseLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mUnalignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mAlignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        pictureCountPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mStatsBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mStatsTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBackgroundPaint.setColor(backgroundColor); // TODO: Get rid of background paint        mBaseLinePaint.setColor(baseLineColor);        mUnalignedPaint.setColor(unalignedIndicatorColor);        mAlignedPaint.setColor(alignedIndicatorColor);        pictureCountPaint.setColor(baseLineColor);        mStatsBackgroundPaint.setColor(0x60969696);        mStatsTextPaint.setColor(0xC0FFFFFF);        mBaseLinePaint.setStyle(Paint.Style.STROKE);        mUnalignedPaint.setStyle(Paint.Style.STROKE);        mAlignedPaint.setStyle(Paint.Style.STROKE);        pictureCountPaint.setStyle(Paint.Style.FILL);        mStatsBackgroundPaint.setStyle(Paint.Style.FILL);        mBaseLinePaint.setStrokeWidth(mStrokeWidth);        mUnalignedPaint.setStrokeWidth(mStrokeWidth);        mAlignedPaint.setStrokeWidth(mStrokeWidth);        pictureCountPaint.setStrokeWidth(3 * mStrokeWidth / 4);        mStatsTextPaint.setTextSize(spToPixels(5));        mStatsTextPaint.setTextAlign(Paint.Align.LEFT);    }    /**     * Initiates the sensor and registers it for the first time     */    private void initSensors() {        mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);        mGravitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);        mMagneticFieldSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);        mRotationVector = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);        registerSensorListener();    }    @Override    public boolean isInEditMode() {        return true;    }    @Override    public void onAccuracyChanged(Sensor sensor, int accuracy) {    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        drawBase(canvas);        drawIndicator(canvas);        drawStats(canvas);    }    @Override    public void onSensorChanged(SensorEvent event) {        if (event.sensor.getType() == Sensor.TYPE_GRAVITY) {            // units in m/s^2            double yAxisGravity = event.values[1];            zDeviceGravity = event.values[2];            // Angle in degrees of device offset from horizontal            horizontalOffset = Math.toDegrees(Math.acos(yAxisGravity / SensorManager.GRAVITY_EARTH)) - 90;            if (horizontalOffset < 0) {                horizontalOffset += 360;            }            float epsilon = 2f;            float horizontal = 0f; // Angle in degrees representing the horizontal            if (horizontalOffset > (360 - epsilon) || horizontalOffset < (horizontal + epsilon)) {                isAligned = true;                if (mEventListener != null) {                    mEventListener.onAligned();                }            } else {                isAligned = false;                if (mEventListener != null) {                    mEventListener.onUnAligned(horizontalOffset);                }            }            invalidate();            return;        }        final float alpha = 0.97f;        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {            // mGravityOrientation = event.values;            Log.d(TAG, "Device acceleration: X[" + event.values[0] + "]     Y[" + event.values[1] + "]      Z[" + event.values[2] + "]   Time from last measurement: " + (System.nanoTime() - sysTime));            sysTime = System.nanoTime();            mGravityOrientation[0] = alpha * mGravityOrientation[0] + (1 - alpha) * event.values[0];            mGravityOrientation[1] = alpha * mGravityOrientation[1] + (1 - alpha) * event.values[1];            mGravityOrientation[2] = alpha * mGravityOrientation[2] + (1 - alpha) * event.values[2];        }        if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {            // mGeomagneticOrientation = event.values;            mGeomagneticOrientation[0] = alpha * mGeomagneticOrientation[0] + (1 - alpha) * event.values[0];            mGeomagneticOrientation[1] = alpha * mGeomagneticOrientation[1] + (1 - alpha) * event.values[1];            mGeomagneticOrientation[2] = alpha * mGeomagneticOrientation[2] + (1 - alpha) * event.values[2];        }        if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {            float rotationMatrix[] = new float[9];            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values);            mHorizonOffset = (float) Math.toDegrees(Math.acos(rotationMatrix[6])); //only from 0 -> 180            if (zDeviceGravity > 0) {                mHorizonOffset = 360 - mHorizonOffset;            }            mHorizonOffset = 180 - mHorizonOffset;            if (mHorizonOffset < 0) {                mHorizonOffset += 360;            }        }        float R[] = new float[9];        float I[] = new float[9];        boolean success = SensorManager.getRotationMatrix(R, I, mGravityOrientation, mGeomagneticOrientation);        if (success) {            float beta = 0.98f;            float orientation[] = new float[3];            SensorManager.getOrientation(R, orientation);            float angle = (float) Math.toDegrees(orientation[0]);            // Make angle increase in direction opposite to motion for better effect            angle = 360 - ((angle + 360) % 360);            angleOffNorth = (beta * angleOffNorth) + ((1 - beta) * angle);            // Redraw the view            invalidate();        }    }    /**     * An EventListener can be registered with the HorizontalOffsetView so it     * can be notified when the device becomes horizontal, and when it is no     * longer horizontal     */    public interface EventListener {        /**         * Called when the device first becomes horizontal         */        public void onAligned();        /**         * Called when the device first becomes non-horizontal with an argument         * of the device offset in degrees         */        public void onUnAligned(double offset);    }    /**     * Gives this view a new EventListener     */    public void registerEventListener(EventListener listener) {        mEventListener = listener;    }    public void registerSensorListener() {        mSensorManager.registerListener(this, mGravitySensor, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mMagneticFieldSensor, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mRotationVector, SensorManager.SENSOR_DELAY_GAME);    }    public void setAlignedIndicatorColor(int alignedIndicatorColor) {        this.alignedIndicatorColor = alignedIndicatorColor;        invalidate();        requestLayout();    }    public void setBackgroundColor(int backgroundColor) {        this.backgroundColor = backgroundColor;        invalidate();        requestLayout();    }    public void setBaseLineColor(int baseLineColor) {        this.baseLineColor = baseLineColor;        invalidate();        requestLayout();    }    public void setUnalignedIndicatorColor(int unalignedIndicatorColor) {        this.unalignedIndicatorColor = unalignedIndicatorColor;        invalidate();        requestLayout();    }    /**     * Removes the EventListener     */    public void unregisterEventListener() {        mEventListener = null;    }    /**     * unregisterSensorListener() needs to be called when the widget is no     * longer in use to prevent leaking the sensor and draining battery life. A     * good idea would be to call it in onPause() of whatever Activity or     * Fragment is hosting this view.     */    public void unregisterSensorListener() {        mSensorManager.unregisterListener(this);    }}