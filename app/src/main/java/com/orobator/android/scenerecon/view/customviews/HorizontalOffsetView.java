package com.orobator.android.scenerecon.view.customviews;import android.content.Context;import android.content.res.Resources;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Paint;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.util.AttributeSet;import android.util.Log;import android.util.TypedValue;import android.view.View;import com.orobator.android.scenerecon.R;import java.util.Vector;/** * HorizontalOffSetView is a custom view used to indicate if the device is * horizontal with respect to the ground */public class HorizontalOffsetView extends View implements SensorEventListener {    private static final String TAG = "HorizontalOffsetView";    private int backgroundColor;    private int baseLineColor;    private int unalignedIndicatorColor;    private int alignedIndicatorColor;    private double horizontalOffset = 0;    private float mRoll = 0f;    private float mStrokeWidth;    private float mCircleRadius;    private boolean isAligned;    private Paint mBackgroundPaint;    private Paint mBaseLinePaint;    private Paint mUnalignedPaint;    private Paint mAlignedPaint;    private Paint mIndicatorPaint;    private EventListener mEventListener;    private SensorManager mSensorManager;    private Sensor mGravitySensor;    private Sensor mOrientationVectorSensor;    private Vector<YawCircle> mYawCircles;    public HorizontalOffsetView(Context context, AttributeSet attrs) {        super(context, attrs);        TypedArray typedArray = context.getTheme().obtainStyledAttributes(                attrs, R.styleable.HorizontalOffsetView, 0, 0);        try {            backgroundColor = typedArray.getColor(R.styleable.HorizontalOffsetView_background_color, 0);            baseLineColor = typedArray.getColor(R.styleable.HorizontalOffsetView_base_line_color, 0);            unalignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_unaligned, 0);            alignedIndicatorColor = typedArray.getColor(R.styleable.HorizontalOffsetView_indicator_color_aligned, 0);        } finally {            typedArray.recycle();        }        initConstants();        initSensor();        initPaints();        initYawCircles();    }    /**     * Draws the baseline that the indicator line is to align with.     */    private void drawBase(Canvas canvas) {        for (YawCircle yawCircle : mYawCircles) {            yawCircle.drawSelf(canvas, mRoll);        }    }    private void drawIndicatorCircle(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Draw the circle in the base line        mIndicatorPaint = isAligned ? mAlignedPaint : mUnalignedPaint;        canvas.drawCircle(centerX, centerY, mCircleRadius, mIndicatorPaint);    }    private void drawIndicatorLine(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Lines are drawn from left to right        // Line coordinates touching edges of screen        float startX_left = 0f;        float startY_left = (float) (centerY - centerX * Math.tan(Math.toRadians(horizontalOffset)));  // Depends on horizontal offset        float stopX_right = (float) canvas.getWidth();        float stopY_right = (float) (centerY + centerX * Math.tan(Math.toRadians(horizontalOffset))); // Depends on horizontal offset        // Line coordinates touching indicator circle        float stopX_left = centerX - (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float stopY_left = centerY - (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        float startX_right = centerX + (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float startY_right = centerY + (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        canvas.drawLine(startX_left, startY_left, stopX_left, stopY_left, mIndicatorPaint);        canvas.drawLine(startX_right, startY_right, stopX_right, stopY_right, mIndicatorPaint);    }    private void drawIndicator(Canvas canvas) {        drawIndicatorCircle(canvas);        drawIndicatorLine(canvas);    }    public int getAlignedIndicatorColor() {        return alignedIndicatorColor;    }    public int getBackgroundColor() {        return backgroundColor;    }    public int getBaseLineColor() {        return baseLineColor;    }    public int getUnalignedIndicatorColor() {        return unalignedIndicatorColor;    }    private void initConstants() {        int thickness = 2; // Thickness of line in dp        Resources r = getResources();        mStrokeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, thickness, r.getDisplayMetrics());        int radiusDP = 26; // radius in DP        mCircleRadius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, radiusDP, r.getDisplayMetrics()); // radius in pixels    }    /**     * Set up Paint objects for drawing. Instantiating Paint objects is     * expensive so don't do it in onDraw()     */    private void initPaints() {        mBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBaseLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mUnalignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mAlignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBackgroundPaint.setColor(backgroundColor); // TODO: Get rid of background paint        mBaseLinePaint.setColor(baseLineColor);        mUnalignedPaint.setColor(unalignedIndicatorColor);        mAlignedPaint.setColor(alignedIndicatorColor);        mBaseLinePaint.setStyle(Paint.Style.STROKE);        mUnalignedPaint.setStyle(Paint.Style.STROKE);        mAlignedPaint.setStyle(Paint.Style.STROKE);        mBaseLinePaint.setStrokeWidth(mStrokeWidth);        mUnalignedPaint.setStrokeWidth(mStrokeWidth);        mAlignedPaint.setStrokeWidth(mStrokeWidth);    }    /**     * Initiates the sensor and registers it for the first time     */    private void initSensor() {        mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);        mGravitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);        mOrientationVectorSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);        registerSensorListener();    }    /**     * Instantiate YawCircles in the beginning to avoid repeated object     * creation in onDraw()     */    public void initYawCircles() {        int brethrenCount = 18; // TODO: change to be configurable, for now each circle will cover 20 degrees        mYawCircles = new Vector<YawCircle>();        for (int i = 0; i < brethrenCount; i++) {            float circleAngle = (360 / brethrenCount) * i;            YawCircle yawCircle = new YawCircle(brethrenCount, circleAngle, mBaseLinePaint, mCircleRadius);            mYawCircles.add(yawCircle);        }    }    @Override    public void onAccuracyChanged(Sensor sensor, int accuracy) {    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        drawBase(canvas);        drawIndicator(canvas);    }    @Override    public void onSensorChanged(SensorEvent event) {        if (event.sensor.getType() == Sensor.TYPE_GRAVITY) {            // units in m/s^2            double yAxisGravity = event.values[1];            // Angle in degrees of device offset from horizontal            horizontalOffset = Math.toDegrees(Math.acos(yAxisGravity / SensorManager.GRAVITY_EARTH)) - 90;            if (horizontalOffset < 0) {                horizontalOffset += 360;            }            Log.d(TAG, "horizontal offset: " + horizontalOffset);            float epsilon = 2f;            float horizontal = 0f; // Angle in degrees representing the horizontal            if (horizontalOffset > (horizontal - epsilon) && horizontalOffset < (horizontal + epsilon)) {                isAligned = true;                if (mEventListener != null) {                    mEventListener.onAligned();                }            } else {                isAligned = false;                if (mEventListener != null) {                    mEventListener.onUnAligned(horizontalOffset);                }            }            // Redraw the view            invalidate();        }        if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {            double xQuaternion = event.values[0];            double yQuaternion = event.values[1];            double zQuaternion = event.values[2];            double wQuaternion = event.values[3];            // Y is tangential to the ground at the device's current location            // and points towards magnetic north.            double yaw = Math.toDegrees(Math.atan2(2.0 * (yQuaternion * zQuaternion + wQuaternion * xQuaternion), wQuaternion * wQuaternion - xQuaternion * xQuaternion - yQuaternion * yQuaternion + zQuaternion * zQuaternion));            // Angle off of horizon            double pitch = Math.toDegrees(Math.asin(-2.0 * (xQuaternion * zQuaternion - wQuaternion * yQuaternion)));//            double roll = Math.toDegrees(Math.atan2(2.0 * (xQuaternion * yQuaternion + wQuaternion * zQuaternion), wQuaternion * wQuaternion + xQuaternion * xQuaternion - yQuaternion * yQuaternion - zQuaternion * zQuaternion));            double roll = Math.toDegrees(Math.atan2(yQuaternion, xQuaternion));            if (roll < 0) {                roll += 360;            }            float rotationMatrix[] = new float[9];            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values);//            double roll = Math.toDegrees(Math.acos(rotationMatrix[8]));            double upDown = Math.toDegrees(Math.acos(rotationMatrix[6])); //only from 0 -> 180            float rotationMatrixTranspose[] = new float[9];            rotationMatrixTranspose[0] = rotationMatrix[0];            rotationMatrixTranspose[1] = rotationMatrix[3];            rotationMatrixTranspose[2] = rotationMatrix[6];            rotationMatrixTranspose[3] = rotationMatrix[1];            rotationMatrixTranspose[4] = rotationMatrix[4];            rotationMatrixTranspose[5] = rotationMatrix[7];            rotationMatrixTranspose[6] = rotationMatrix[2];            rotationMatrixTranspose[7] = rotationMatrix[5];            rotationMatrixTranspose[8] = rotationMatrix[8];            float cameraVectorBodyAxis[] = {0f, 0f, -1f};//            float cameraVectorWorldAxis[] =//            horizontalOffset = roll;//            Log.d(TAG, "Yaw: " + yaw + " Pitch: " + pitch + " Roll: " + roll);            mRoll = (float) roll;//            float epsilon = 2;////            if (yaw < epsilon) {//                if (mEventListener != null) {//                    mEventListener.onAligned();//                    isAligned = true;//                }//            }////            if (yaw > epsilon) {//                if (isAligned) {//                    isAligned = false;//                    if (mEventListener != null) {//                        mEventListener.onUnAligned(horizontalOffset);//                    }//                }//            }            // Redraw the view            invalidate();        }    }    /**     * An EventListener can be registered with the HorizontalOffsetView so it     * can be notified when the device becomes horizontal, and when it is no     * longer horizontal     */    public interface EventListener {        /**         * Called when the device first becomes horizontal         */        public void onAligned();        /**         * Called when the device first becomes non-horizontal with an argument         * of the device offset in degrees         */        public void onUnAligned(double offset);    }    /**     * Gives this view a new EventListener     */    public void registerEventListener(EventListener listener) {        mEventListener = listener;    }    public void registerSensorListener() {        mSensorManager.registerListener(this, mGravitySensor, SensorManager.SENSOR_DELAY_GAME);        mSensorManager.registerListener(this, mOrientationVectorSensor, SensorManager.SENSOR_DELAY_GAME);    }    public void setAlignedIndicatorColor(int alignedIndicatorColor) {        this.alignedIndicatorColor = alignedIndicatorColor;        invalidate();        requestLayout();    }    public void setBackgroundColor(int backgroundColor) {        this.backgroundColor = backgroundColor;        invalidate();        requestLayout();    }    public void setBaseLineColor(int baseLineColor) {        this.baseLineColor = baseLineColor;        invalidate();        requestLayout();    }    public void setUnalignedIndicatorColor(int unalignedIndicatorColor) {        this.unalignedIndicatorColor = unalignedIndicatorColor;        invalidate();        requestLayout();    }    /**     * Removes the EventListener     */    public void unregisterEventListener() {        mEventListener = null;    }    /**     * unregisterSensorListener() needs to be called when the widget is no longer in use to prevent     * leaking the sensor and draining battery life. A good idea would be to     * call it in onPause() of whatever Activity or Fragment is hosting this view     */    public void unregisterSensorListener() {        mSensorManager.unregisterListener(this);    }}